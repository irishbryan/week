import moment from "moment";
import { TimeVariables } from "./time-variables";
import { getDurationInMinutes, getMinutesSinceMidnight } from "./time-utils";

/**
 * Helper function to calculate height of event based on number
 * of time segments its duration requires.
 * @param {Date} start of event.
 * @param {Date} end of event.
 * @return {Integer} height of event in pixels.
 */
export const getEventHeight = (start, end) => {
  const { SEGMENT_DURATION_MINS, SEGMENT_PIXEL_HEIGHT } = TimeVariables;

  return (
    (getDurationInMinutes(start, end) / SEGMENT_DURATION_MINS) *
    SEGMENT_PIXEL_HEIGHT
  );
};

/**
 * Helper function that calculates how many pixels off the top of the day
 * container this event should be positioned, based on calculating number of
 * time segments that are between midnight and start of event.
 *
 * TODO: This is currently too difficult to parse for another coder.
 *
 * @param { Date } start representing the start time of event.
 * @param { Integer } headerHeight representing height of day header to account for.
 * @returns { Integer } number of pixels that should be used for absolute `top`.
 */
export const getTopOfEventPosition = (start, headerHeight) => {
  const { SEGMENT_DURATION_MINS, SEGMENT_PIXEL_HEIGHT } = TimeVariables;

  let timeSegmentPixelsToSkip =
    (getMinutesSinceMidnight(start) / SEGMENT_DURATION_MINS) *
    SEGMENT_PIXEL_HEIGHT;

  return timeSegmentPixelsToSkip + headerHeight;
};

/**
 * Calculates new end time for event based on provided height of event.
 * @param {Date} start - Date representing start time of event.
 * @param {Integer} newEventHeight - height of event after resizing.
 * @returns {Date} new end time of event.
 */
export const getNewEndDate = (start, newEventHeight) => {
  const { SEGMENT_DURATION_MINS, SEGMENT_PIXEL_HEIGHT } = TimeVariables;

  let durationInSegments = Math.round(newEventHeight / SEGMENT_PIXEL_HEIGHT);

  return moment(start)
    .add(durationInSegments * SEGMENT_DURATION_MINS, "minutes")
    .toDate();
};

/**
 * Returns a new event object altered to reflect provided drag data, which is
 * generated by `react-draggable` library.
 *
 * @param {Object} event - representing event that was dragged.
 * @param {Object} dragData - object provided by `react-draggable` library when drag finishes.
 * @param {dayColumnWidth} number - size in pixels of individual day column (for day movement arithmetic)
 * @returns {Object} new event object, which can be persisted.
 */
export const createNewEventBasedOnDrag = (event, dragData, dayColumnWidth) => {
  const horizontalMovement = dragData.lastX;
  const verticalMovement = dragData.lastY;
  let startMoment = moment(event.start);
  let endMoment = moment(event.end);

  // Handle horizontal movement (change of date).
  if (horizontalMovement !== 0 && horizontalMovement % dayColumnWidth === 0) {
    startMoment.add(horizontalMovement / dayColumnWidth, "days");
    endMoment.add(horizontalMovement / dayColumnWidth, "days");
  }

  // Handle vertical movement (change of time).
  if (
    verticalMovement !== 0 &&
    verticalMovement % TimeVariables.SEGMENT_PIXEL_HEIGHT === 0
  ) {
    startMoment.add(
      (verticalMovement / TimeVariables.SEGMENT_PIXEL_HEIGHT) *
        TimeVariables.SEGMENT_DURATION_MINS,
      "minutes"
    );

    endMoment.add(
      (verticalMovement / TimeVariables.SEGMENT_PIXEL_HEIGHT) *
        TimeVariables.SEGMENT_DURATION_MINS,
      "minutes"
    );
  }

  return {
    ...event,
    start: startMoment.toDate(),
    end: endMoment.toDate()
  };
};
